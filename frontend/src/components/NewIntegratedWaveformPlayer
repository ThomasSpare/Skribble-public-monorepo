import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Play, Pause, SkipBack, SkipForward, Volume2, VolumeX, Loader2, Download, ZoomIn, ZoomOut, Home } from 'lucide-react';

interface WaveformPlayerProps {
  audioUrl?: string;
  audioFileId?: string;
  projectId?: string;
  title?: string;
  onTimeUpdate?: (currentTime: number) => void;
  onLoadComplete?: (duration: number) => void;
  currentUser?: {
    id: string;
    username: string;
    email: string;
  };
}

interface AnnotationType {
  id: string;
  audioFileId: string;
  userId: string;
  user: {
    id: string;
    username: string;
    email: string;
    role: string;
    subscriptionTier: string;
    profileImage?: string;
    createdAt: string;
    updatedAt: string;
  };
  timestamp: number;
  text: string;
  voiceNoteUrl?: string;
  annotationType: 'comment' | 'marker' | 'voice' | 'section' | 'issue' | 'approval';
  priority: 'low' | 'medium' | 'high' | 'critical';
  status: 'pending' | 'in-progress' | 'resolved' | 'approved';
  parentId?: string;
  mentions: string[];
  createdAt: string;
  updatedAt: string;
}

interface HoveredAnnotation {
  id: string;
  x: number;
  timestamp: number;
  text: string;
  user: string;
  type: string;
}

export default function EnhancedWaveformPlayer({ 
  audioUrl = "https://www.soundjay.com/misc/sounds/bell-ringing-05.wav", // Demo audio
  audioFileId = "demo-audio-file",
  projectId = "demo-project",
  title = "Demo Track - Enhanced Player",
  onTimeUpdate,
  onLoadComplete,
  currentUser = { id: "demo-user", username: "Demo User", email: "demo@test.com" }
}: WaveformPlayerProps) {
  // Audio player state
  const [isPlaying, setIsPlaying] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [duration, setDuration] = useState(180); // Demo duration
  const [currentTime, setCurrentTime] = useState(0);
  const [volume, setVolume] = useState(0.8);
  const [isMuted, setIsMuted] = useState(false);
  const [waveformData, setWaveformData] = useState<number[]>([]);
  const [isGeneratingWaveform, setIsGeneratingWaveform] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isAudioReady, setIsAudioReady] = useState(true);
  const [userInteracted, setUserInteracted] = useState(true);

  // Annotation state
  const [annotations, setAnnotations] = useState<AnnotationType[]>([]);
  const [showAnnotations, setShowAnnotations] = useState(true);

  // Zoom and scroll state
  const [zoomLevel, setZoomLevel] = useState(1);
  const [scrollOffset, setScrollOffset] = useState(0);
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, offset: 0 });

  // Enhanced annotation interaction state
  const [hoveredAnnotation, setHoveredAnnotation] = useState<HoveredAnnotation | null>(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [clickFeedback, setClickFeedback] = useState<{x: number, timestamp: number} | null>(null);

  // BPM and musical grid state
  const [bpm, setBpm] = useState(120);
  const [beatsPerBar, setBeatsPerBar] = useState(4);
  const [gridMode, setGridMode] = useState<'time' | 'musical'>('time');
  const [showBeats, setShowBeats] = useState(true);
  const [showBars, setShowBars] = useState(true);
  const [tapTimes, setTapTimes] = useState<number[]>([]);
  const [isDetectingBpm, setIsDetectingBpm] = useState(false);

  // Refs
  const audioRef = useRef<HTMLAudioElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const waveformContainerRef = useRef<HTMLDivElement>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const sourceRef = useRef<MediaElementAudioSourceNode | null>(null);
  const animationFrameRef = useRef<number | null>(null);
  
  // Constants
  const CANVAS_HEIGHT = 180; // Increased height
  const MIN_ZOOM = 0.5;
  const MAX_ZOOM = 10;
  const ANNOTATION_BUBBLE_HEIGHT = 32;
  const ANNOTATION_BUBBLE_WIDTH = 36;

  // Generate demo waveform data on mount
  useEffect(() => {
    const generateDemoWaveform = () => {
      const samples = Math.floor(duration * 50);
      const waveform = Array.from({ length: samples }, (_, i) => {
        // Create a more realistic waveform pattern
        const baseLevel = 0.3;
        const variation = 0.4;
        const frequency = 0.1;
        return baseLevel + Math.sin(i * frequency) * variation + (Math.random() - 0.5) * 0.2;
      });
      setWaveformData(waveform);
      setIsLoading(false);
    };

    generateDemoWaveform();
  }, [duration]);

  // Demo annotations
  useEffect(() => {
    const demoAnnotations: AnnotationType[] = [
      {
        id: "demo-1",
        audioFileId: "demo-audio-file",
        userId: "demo-user",
        user: {
          id: "demo-user",
          username: "Producer Mike",
          email: "mike@demo.com",
          role: "producer",
          subscriptionTier: "pro",
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        },
        timestamp: 15.5,
        text: "Add more punch to the kick here",
        annotationType: "issue",
        priority: "high",
        status: "pending",
        mentions: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      },
      {
        id: "demo-2",
        audioFileId: "demo-audio-file",
        userId: "demo-user2",
        user: {
          id: "demo-user2",
          username: "Artist Jane",
          email: "jane@demo.com",
          role: "artist",
          subscriptionTier: "indie",
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        },
        timestamp: 45.2,
        text: "Love the melody here! Maybe add some reverb?",
        annotationType: "comment",
        priority: "medium",
        status: "pending",
        mentions: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      },
      {
        id: "demo-3",
        audioFileId: "demo-audio-file",
        userId: "demo-user",
        user: {
          id: "demo-user",
          username: "Engineer Bob",
          email: "bob@demo.com",
          role: "producer",
          subscriptionTier: "studio",
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        },
        timestamp: 78.8,
        text: "Chorus section - perfect energy!",
        annotationType: "approval",
        priority: "low",
        status: "approved",
        mentions: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }
    ];
    setAnnotations(demoAnnotations);
  }, []);

  // Calculate visible waveform based on zoom and scroll
  const getVisibleWaveform = useCallback(() => {
    if (waveformData.length === 0 || duration === 0) return [];
    
    const samplesPerSecond = waveformData.length / duration;
    const visibleDuration = duration / zoomLevel;
    const startTime = scrollOffset;
    const endTime = Math.min(startTime + visibleDuration, duration);
    
    const startIndex = Math.floor(startTime * samplesPerSecond);
    const endIndex = Math.min(Math.ceil(endTime * samplesPerSecond), waveformData.length);
    
    return waveformData.slice(startIndex, endIndex);
  }, [waveformData, duration, zoomLevel, scrollOffset]);

  // Calculate musical markers based on BPM
  const getMusicalMarkers = useCallback((startTime: number, endTime: number, visibleDuration: number) => {
    const secondsPerBeat = 60 / bpm;
    const secondsPerBar = secondsPerBeat * beatsPerBar;
    const markers = [];
    
    // Add bar markers
    if (showBars) {
      const firstBar = Math.floor(startTime / secondsPerBar);
      const lastBar = Math.ceil(endTime / secondsPerBar);
      
      for (let bar = firstBar; bar <= lastBar; bar++) {
        const time = bar * secondsPerBar;
        if (time >= startTime && time <= endTime && time <= duration) {
          const position = ((time - startTime) / visibleDuration) * 100;
          markers.push({
            time,
            position,
            isMajor: true,
            isBar: true,
            label: `${bar + 1}`
          });
        }
      }
    }
    
    // Add beat markers
    if (showBeats && zoomLevel > 1) {
      const firstBeat = Math.floor(startTime / secondsPerBeat);
      const lastBeat = Math.ceil(endTime / secondsPerBeat);
      
      for (let beat = firstBeat; beat <= lastBeat; beat++) {
        const time = beat * secondsPerBeat;
        if (time >= startTime && time <= endTime && time <= duration) {
          const position = ((time - startTime) / visibleDuration) * 100;
          const beatInBar = (beat % beatsPerBar) + 1;
          const bar = Math.floor(beat / beatsPerBar) + 1;
          
          // Only add beat markers that aren't already bar markers
          if (beatInBar !== 1) {
            markers.push({
              time,
              position,
              isMajor: false,
              isBar: false,
              label: `${bar}.${beatInBar}`
            });
          }
        }
      }
    }
    
    return markers.sort((a, b) => a.time - b.time);
  }, [bpm, beatsPerBar, showBeats, showBars, zoomLevel]);

  // Calculate time markers for the ruler
  const getTimeMarkers = useCallback(() => {
    const visibleDuration = duration / zoomLevel;
    const startTime = scrollOffset;
    const endTime = startTime + visibleDuration;
    
    if (gridMode === 'musical') {
      return getMusicalMarkers(startTime, endTime, visibleDuration);
    }
    
    let interval: number;
    if (visibleDuration <= 10) {
      interval = 0.5;
    } else if (visibleDuration <= 30) {
      interval = 1;
    } else if (visibleDuration <= 60) {
      interval = 5;
    } else if (visibleDuration <= 300) {
      interval = 10;
    } else if (visibleDuration <= 600) {
      interval = 30;
    } else {
      interval = 60;
    }
    
    const markers = [];
    const firstMarker = Math.ceil(startTime / interval) * interval;
    
    for (let time = firstMarker; time <= endTime; time += interval) {
      if (time >= 0 && time <= duration) {
        const position = ((time - startTime) / visibleDuration) * 100;
        markers.push({
          time,
          position,
          isMajor: time % (interval * 2) === 0 || interval >= 30,
          isBar: false,
          label: formatRulerTime(time)
        });
      }
    }
    
    return markers;
  }, [duration, zoomLevel, scrollOffset, gridMode, getMusicalMarkers]);

  // Format time for display
  const formatRulerTime = (seconds: number) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    const decimals = Math.floor((seconds % 1) * 10);
    
    if (seconds < 60 && duration / zoomLevel <= 30) {
      return `${remainingSeconds}.${decimals}s`;
    } else if (seconds < 60) {
      return `${remainingSeconds}s`;
    } else {
      return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }
  };

  const formatTime = (time: number) => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  // Format time for BPM display
  const formatMusicalTime = (seconds: number) => {
    const secondsPerBeat = 60 / bpm;
    const secondsPerBar = secondsPerBeat * beatsPerBar;
    
    const bar = Math.floor(seconds / secondsPerBar) + 1;
    const beat = Math.floor((seconds % secondsPerBar) / secondsPerBeat) + 1;
    const tick = Math.floor(((seconds % secondsPerBeat) / secondsPerBeat) * 96); // 96 ticks per beat
    
    return `${bar}.${beat}.${tick.toString().padStart(2, '0')}`;
  };

  // Get annotation color based on type and priority
  const getAnnotationColor = (annotation: AnnotationType): string => {
    if (annotation.annotationType === 'issue') return '#ef4444';
    if (annotation.annotationType === 'approval') return '#22c55e';
    if (annotation.annotationType === 'marker') return '#f59e0b';
    if (annotation.annotationType === 'voice') return '#8b5cf6';
    if (annotation.annotationType === 'section') return '#06b6d4';
    
    switch (annotation.priority) {
      case 'critical': return '#ef4444';
      case 'high': return '#f59e0b';
      case 'medium': return '#eab308';
      case 'low': return '#22c55e';
      default: return '#71A9F7';
    }
  };

  // Draw time-based grid
  const drawTimeGrid = (ctx: CanvasRenderingContext2D, width: number, height: number, visibleDuration: number) => {
    ctx.strokeStyle = 'rgba(198, 216, 255, 0.1)';
    ctx.lineWidth = 1;
    
    const gridSpacing = Math.max(20, width / (visibleDuration / 5));
    
    for (let x = 0; x < width; x += gridSpacing) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    }
    
    const horizontalLines = 5;
    for (let i = 1; i < horizontalLines; i++) {
      const y = (height / horizontalLines) * i;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }
  };

  // Draw musical grid based on BPM
  const drawMusicalGrid = (ctx: CanvasRenderingContext2D, width: number, height: number, visibleDuration: number) => {
    const startTime = scrollOffset;
    const endTime = scrollOffset + visibleDuration;
    const secondsPerBeat = 60 / bpm;
    const secondsPerBar = secondsPerBeat * beatsPerBar;
    
    // Draw bar lines (major)
    if (showBars) {
      ctx.strokeStyle = 'rgba(198, 216, 255, 0.3)';
      ctx.lineWidth = 2;
      
      const firstBar = Math.floor(startTime / secondsPerBar);
      const lastBar = Math.ceil(endTime / secondsPerBar);
      
      for (let bar = firstBar; bar <= lastBar; bar++) {
        const time = bar * secondsPerBar;
        if (time >= startTime && time <= endTime && time <= duration) {
          const x = ((time - startTime) / visibleDuration) * width;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
      }
    }
    
    // Draw beat lines (minor)
    if (showBeats && zoomLevel > 1) {
      ctx.strokeStyle = 'rgba(198, 216, 255, 0.15)';
      ctx.lineWidth = 1;
      
      const firstBeat = Math.floor(startTime / secondsPerBeat);
      const lastBeat = Math.ceil(endTime / secondsPerBeat);
      
      for (let beat = firstBeat; beat <= lastBeat; beat++) {
        const time = beat * secondsPerBeat;
        if (time >= startTime && time <= endTime && time <= duration) {
          const beatInBar = beat % beatsPerBar;
          // Don't draw beat lines on bar positions
          if (beatInBar !== 0) {
            const x = ((time - startTime) / visibleDuration) * width;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
          }
        }
      }
    }
    
    // Draw horizontal lines
    ctx.strokeStyle = 'rgba(198, 216, 255, 0.1)';
    ctx.lineWidth = 1;
    const horizontalLines = 5;
    for (let i = 1; i < horizontalLines; i++) {
      const y = (height / horizontalLines) * i;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }
  };

  // Draw grid lines
  const drawGrid = (ctx: CanvasRenderingContext2D, width: number, height: number, visibleDuration: number) => {
    if (gridMode === 'musical') {
      drawMusicalGrid(ctx, width, height, visibleDuration);
    } else {
      drawTimeGrid(ctx, width, height, visibleDuration);
    }
  };

  // Draw annotations
  const drawAnnotations = (ctx: CanvasRenderingContext2D, width: number, height: number, visibleDuration: number) => {
    const visibleStart = scrollOffset;
    const visibleEnd = scrollOffset + visibleDuration;
    
    const parentAnnotations = annotations.filter(annotation => !annotation.parentId);
    
    parentAnnotations.forEach(annotation => {
      if (annotation.timestamp >= visibleStart && annotation.timestamp <= visibleEnd) {
        const x = ((annotation.timestamp - visibleStart) / visibleDuration) * width;
        const isHovered = hoveredAnnotation?.id === annotation.id;
        
        const bubbleX = x - ANNOTATION_BUBBLE_WIDTH / 2;
        const bubbleY = 5;
        const bubbleColor = getAnnotationColor(annotation);
        const scale = isHovered ? 1.1 : 1;
        
        ctx.save();
        
        if (isHovered) {
          ctx.translate(x, bubbleY + ANNOTATION_BUBBLE_HEIGHT / 2);
          ctx.scale(scale, scale);
          ctx.translate(-x, -(bubbleY + ANNOTATION_BUBBLE_HEIGHT / 2));
        }
        
        // Draw bubble
        ctx.fillStyle = bubbleColor;
        ctx.shadowColor = isHovered ? bubbleColor : 'rgba(0,0,0,0.3)';
        ctx.shadowBlur = isHovered ? 12 : 6;
        ctx.shadowOffsetY = 2;
        
        ctx.beginPath();
        ctx.roundRect(bubbleX, bubbleY, ANNOTATION_BUBBLE_WIDTH, ANNOTATION_BUBBLE_HEIGHT - 6, 8);
        ctx.fill();
        
        // Draw tail
        ctx.beginPath();
        ctx.moveTo(x - 6, bubbleY + ANNOTATION_BUBBLE_HEIGHT - 6);
        ctx.lineTo(x, bubbleY + ANNOTATION_BUBBLE_HEIGHT + 2);
        ctx.lineTo(x + 6, bubbleY + ANNOTATION_BUBBLE_HEIGHT - 6);
        ctx.closePath();
        ctx.fill();
        
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;
        
        // Draw icon
        ctx.fillStyle = 'white';
        const iconSize = isHovered ? 14 : 12;
        ctx.save();
        ctx.translate(x, bubbleY + 16);
        
        // Simple icon based on type
        if (annotation.annotationType === 'issue') {
          ctx.fillRect(-1, -6, 2, 8);
          ctx.beginPath();
          ctx.arc(0, 4, 1.5, 0, 2 * Math.PI);
          ctx.fill();
        } else if (annotation.annotationType === 'approval') {
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(-4, 0);
          ctx.lineTo(-1, 3);
          ctx.lineTo(4, -3);
          ctx.stroke();
        } else {
          // Default comment dots
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc((i - 1) * 3, 0, 1, 0, 2 * Math.PI);
            ctx.fill();
          }
        }
        
        ctx.restore();
        
        // Draw vertical line
        ctx.strokeStyle = bubbleColor;
        ctx.lineWidth = isHovered ? 3 : 2;
        ctx.globalAlpha = isHovered ? 0.9 : 0.6;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(x, ANNOTATION_BUBBLE_HEIGHT + 8);
        ctx.lineTo(x, height - 5);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.restore();
      }
    });
  };

  // Main waveform drawing function
  const drawWaveform = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas || waveformData.length === 0) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const { width, height } = canvas;
    const visibleWaveform = getVisibleWaveform();
    const visibleDuration = duration / zoomLevel;
    const progress = duration > 0 ? (currentTime - scrollOffset) / visibleDuration : 0;
    
    ctx.clearRect(0, 0, width, height);
    
    drawGrid(ctx, width, height, visibleDuration);
    
    if (visibleWaveform.length > 0) {
      const barWidth = width / visibleWaveform.length;
      const centerY = height / 2;
      
      visibleWaveform.forEach((sample, i) => {
        const barHeight = sample * height * 0.7;
        const x = i * barWidth;
        const y = centerY - barHeight / 2;
        
        const barProgress = i / visibleWaveform.length;
        if (barProgress <= progress && currentTime >= scrollOffset && currentTime <= scrollOffset + visibleDuration) {
          ctx.fillStyle = '#71A9F7';
        } else {
          ctx.fillStyle = '#6B5CA5';
        }
        
        ctx.fillRect(x, y, Math.max(1, barWidth - 1), barHeight);
      });
    }
    
    drawAnnotations(ctx, width, height, visibleDuration);
    
    if (currentTime >= scrollOffset && currentTime <= scrollOffset + visibleDuration) {
      const progressX = progress * width;
      ctx.strokeStyle = '#C6D8FF';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(progressX, 0);
      ctx.lineTo(progressX, height);
      ctx.stroke();
    }
    
    // Draw click feedback ripple effect
    if (clickFeedback) {
      const rect = canvas.getBoundingClientRect();
      const feedbackX = (clickFeedback.x / rect.width) * width;
      const time = Date.now() % 800;
      const progress = time / 800;
      const radius = progress * 30;
      const alpha = 1 - progress;
      
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = '#C6D8FF';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(feedbackX, height / 2, radius, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.restore();
    }
    
  }, [waveformData, currentTime, duration, annotations, zoomLevel, scrollOffset, hoveredAnnotation, clickFeedback, getVisibleWaveform]);

  // Mouse tracking for hover effects
  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas || !annotations.length) return;

    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    setMousePosition({ x: mouseX, y: mouseY });

    const visibleDuration = duration / zoomLevel;
    const visibleStart = scrollOffset;
    const visibleEnd = scrollOffset + visibleDuration;
    
    const parentAnnotations = annotations.filter(annotation => !annotation.parentId);
    
    let foundHover: HoveredAnnotation | null = null;

    for (const annotation of parentAnnotations) {
      if (annotation.timestamp >= visibleStart && annotation.timestamp <= visibleEnd) {
        const x = ((annotation.timestamp - visibleStart) / visibleDuration) * rect.width;
        const bubbleX = x - ANNOTATION_BUBBLE_WIDTH / 2;
        const bubbleY = 5;
        
        const isOverBubble = mouseX >= bubbleX && 
                            mouseX <= bubbleX + ANNOTATION_BUBBLE_WIDTH && 
                            mouseY >= bubbleY && 
                            mouseY <= bubbleY + ANNOTATION_BUBBLE_HEIGHT;
        
        const isOverLine = mouseX >= x - 4 && 
                          mouseX <= x + 4 && 
                          mouseY >= bubbleY + ANNOTATION_BUBBLE_HEIGHT;

        if (isOverBubble || isOverLine) {
          foundHover = {
            id: annotation.id,
            x: x,
            timestamp: annotation.timestamp,
            text: annotation.text.substring(0, 100) + (annotation.text.length > 100 ? '...' : ''),
            user: annotation.user.username,
            type: annotation.annotationType
          };
          break;
        }
      }
    }

    setHoveredAnnotation(foundHover);
  }, [annotations, duration, zoomLevel, scrollOffset]);

  const handleMouseLeave = useCallback(() => {
    setHoveredAnnotation(null);
  }, []);

  // Canvas click handler
  const handleCanvasClick = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (isDragging) return;
    
    const canvas = canvasRef.current;
    if (!canvas || duration === 0) return;

    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;

    // Check if we clicked on an annotation
    if (hoveredAnnotation) {
      console.log(`Seeking to annotation: ${hoveredAnnotation.timestamp}s`);
      seekTo(hoveredAnnotation.timestamp);
      return;
    }

    const progress = mouseX / rect.width;
    const visibleDuration = duration / zoomLevel;
    const newTime = scrollOffset + (progress * visibleDuration);
    
    seekTo(newTime);
  };

  // Seek function with visual feedback
  const seekTo = (time: number) => {
    const clampedTime = Math.max(0, Math.min(time, duration));
    setCurrentTime(clampedTime);
    
    // Add visual feedback
    const canvas = canvasRef.current;
    if (canvas) {
      const rect = canvas.getBoundingClientRect();
      const visibleDuration = duration / zoomLevel;
      const relativeTime = clampedTime - scrollOffset;
      const x = (relativeTime / visibleDuration) * rect.width;
      
      setClickFeedback({ x, timestamp: clampedTime });
      setTimeout(() => setClickFeedback(null), 800);
    }
  };

  // Mouse wheel zoom
  const handleWheel = useCallback((e: React.WheelEvent<HTMLCanvasElement>) => {
    e.preventDefault();
    
    if (!canvasRef.current) return;
    
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseProgress = mouseX / rect.width;
    
    const visibleDuration = duration / zoomLevel;
    const timeUnderMouse = scrollOffset + (mouseProgress * visibleDuration);
    
    const zoomFactor = e.deltaY > 0 ? 1 / 1.2 : 1.2;
    const newZoomLevel = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel * zoomFactor));
    
    if (newZoomLevel !== zoomLevel) {
      const newVisibleDuration = duration / newZoomLevel;
      const newScrollOffset = Math.max(0, Math.min(
        duration - newVisibleDuration,
        timeUnderMouse - (mouseProgress * newVisibleDuration)
      ));
      
      setZoomLevel(newZoomLevel);
      setScrollOffset(newScrollOffset);
    }
  }, [zoomLevel, scrollOffset, duration]);

  // Playback controls
  const togglePlayPause = () => {
    setIsPlaying(!isPlaying);
  };

  const skipBackward = () => seekTo(currentTime - 10);
  const skipForward = () => seekTo(currentTime + 10);

  const handleVolumeChange = (newVolume: number) => {
    setVolume(newVolume);
  };

  const toggleMute = () => {
    setIsMuted(!isMuted);
  };

  // Zoom controls
  const zoomIn = () => {
    setZoomLevel(prev => Math.min(MAX_ZOOM, prev * 1.5));
  };

  const zoomOut = () => {
    setZoomLevel(prev => {
      const newZoom = Math.max(MIN_ZOOM, prev / 1.5);
      const visibleDuration = duration / prev;
      const newVisibleDuration = duration / newZoom;
      const centerTime = scrollOffset + visibleDuration / 2;
      const newOffset = Math.max(0, Math.min(duration - newVisibleDuration, centerTime - newVisibleDuration / 2));
      setScrollOffset(newOffset);
      return newZoom;
    });
  };

  const resetZoom = () => {
    setZoomLevel(1);
    setScrollOffset(0);
  };

  // Tap tempo functionality
  const handleTapTempo = () => {
    const now = Date.now();
    const newTapTimes = [...tapTimes, now].slice(-8);
    setTapTimes(newTapTimes);

    if (newTapTimes.length >= 2) {
      const intervals = [];
      for (let i = 1; i < newTapTimes.length; i++) {
        intervals.push(newTapTimes[i] - newTapTimes[i - 1]);
      }
      
      const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
      const detectedBpm = Math.round(60000 / avgInterval);
      
      if (detectedBpm >= 60 && detectedBpm <= 200) {
        setBpm(detectedBpm);
      }
    }
  };

  const clearTapTempo = () => {
    setTapTimes([]);
  };

  const detectBpmFromAudio = async () => {
    setIsDetectingBpm(true);
    // Simulate detection
    setTimeout(() => {
      const detectedBpm = 120 + Math.floor(Math.random() * 40);
      setBpm(detectedBpm);
      setIsDetectingBpm(false);
    }, 2000);
  };

  // Animation loop
  useEffect(() => {
    const animate = () => {
      drawWaveform();
      if (isPlaying) {
        setCurrentTime(prev => Math.min(prev + 0.1, duration));
      }
      animationFrameRef.current = requestAnimationFrame(animate);
    };
    animate();
    
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [drawWaveform, isPlaying, duration]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement) {
        return;
      }

      switch (event.code) {
        case 'Space':
          event.preventDefault();
          togglePlayPause();
          break;
        case 'KeyT':
          if (event.shiftKey) {
            event.preventDefault();
            handleTapTempo();
          }
          break;
        case 'KeyG':
          event.preventDefault();
          setGridMode(gridMode === 'time' ? 'musical' : 'time');
          break;
        case 'KeyB':
          if (event.shiftKey) {
            event.preventDefault();
            setShowBeats(!showBeats);
          }
          break;
        case 'KeyR':
          if (event.shiftKey) {
            event.preventDefault();
            setShowBars(!showBars);
          }
          break;
        default:
          break;
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [gridMode, showBeats, showBars, handleTapTempo, togglePlayPause]);

  return (
    <div className="space-y-6">
      {/* Audio Player */}
      <div className="bg-gradient-to-br from-purple-900/20 via-blue-900/20 to-indigo-900/20 backdrop-blur-md rounded-xl p-6 border border-blue-400/20">
        {/* Header */}
        <div className="flex items-center justify-between mb-4 flex-wrap gap-4">
          <h3 className="font-bold text-lg text-blue-100">{title}</h3>
          <div className="flex items-center gap-4 flex-wrap">
            {/* BPM Controls */}
            <div className="flex items-center gap-2 bg-black/20 rounded-lg p-2">
              <label className="text-xs text-blue-300">BPM:</label>
              <input
                type="number"
                min="60"
                max="200"
                value={bpm}
                onChange={(e) => setBpm(Number(e.target.value))}
                className="w-16 px-2 py-1 bg-purple-900/50 border border-blue-400/30 rounded text-blue-100 text-sm focus:border-blue-400 focus:ring-1 focus:ring-blue-400/20"
              />
              <div className="flex gap-1">
                <button
                  onClick={handleTapTempo}
                  className="px-2 py-1 bg-purple-600/50 text-white text-xs rounded hover:bg-purple-600 transition-colors"
                  title="Tap tempo"
                >
                  TAP
                </button>
                <button
                  onClick={clearTapTempo}
                  className="px-1 py-1 bg-black/50 text-blue-300 text-xs rounded hover:bg-black transition-colors"
                  title="Clear taps"
                >
                  âœ•
                </button>
                <button
                  onClick={detectBpmFromAudio}
                  disabled={!isPlaying || isDetectingBpm}
                  className="px-2 py-1 bg-blue-600/50 text-white text-xs rounded hover:bg-blue-600 transition-colors disabled:opacity-50"
                  title="Auto-detect BPM"
                >
                  {isDetectingBpm ? '...' : 'AUTO'}
                </button>
              </div>
              <select
                value={beatsPerBar}
                onChange={(e) => setBeatsPerBar(Number(e.target.value))}
                className="px-2 py-1 bg-purple-900/50 border border-blue-400/30 rounded text-blue-100 text-sm focus:border-blue-400 focus:ring-1 focus:ring-blue-400/20"
              >
                <option value={3}>3/4</option>
                <option value={4}>4/4</option>
                <option value={6}>6/8</option>
                <option value={8}>8/8</option>
              </select>
              {tapTimes.length > 0 && (
                <span className="text-xs text-green-400">
                  {tapTimes.length} taps
                </span>
              )}
            </div>

            {/* Grid Mode Toggle */}
            <div className="flex items-center gap-1 bg-black/20 rounded-lg p-1">
              <button
                onClick={() => setGridMode('time')}
                className={`px-3 py-1 rounded text-xs transition-colors ${
                  gridMode === 'time' 
                    ? 'bg-blue-600 text-white' 
                    : 'text-blue-300 hover:text-blue-100'
                }`}
              >
                Time
              </button>
              <button
                onClick={() => setGridMode('musical')}
                className={`px-3 py-1 rounded text-xs transition-colors ${
                  gridMode === 'musical' 
                    ? 'bg-blue-600 text-white' 
                    : 'text-blue-300 hover:text-blue-100'
                }`}
              >
                Musical
              </button>
            </div>

            {/* Musical Grid Options */}
            {gridMode === 'musical' && (
              <div className="flex items-center gap-2 bg-black/20 rounded-lg p-1">
                <button
                  onClick={() => setShowBars(!showBars)}
                  className={`px-2 py-1 rounded text-xs transition-colors ${
                    showBars 
                      ? 'bg-purple-600 text-white' 
                      : 'text-purple-300 hover:text-blue-300'
                  }`}
                  title="Show/hide bar lines"
                >
                  Bars
                </button>
                <button
                  onClick={() => setShowBeats(!showBeats)}
                  className={`px-2 py-1 rounded text-xs transition-colors ${
                    showBeats 
                      ? 'bg-purple-600 text-white' 
                      : 'text-purple-300 hover:text-blue-300'
                  }`}
                  title="Show/hide beat lines"
                >
                  Beats
                </button>
              </div>
            )}
            
            <button
              onClick={() => setShowAnnotations(!showAnnotations)}
              className={`px-3 py-1 rounded text-sm transition-colors ${
                showAnnotations 
                  ? 'bg-blue-600 text-white' 
                  : 'text-blue-300 hover:text-blue-100'
              }`}
            >
              Annotations ({annotations.length})
            </button>
            
            <div className="flex items-center gap-1 bg-black/20 rounded-lg p-1">
              <button
                onClick={zoomOut}
                className="p-1 text-blue-300 hover:text-blue-100 transition-colors"
                disabled={zoomLevel <= MIN_ZOOM}
              >
                <ZoomOut className="w-4 h-4" />
              </button>
              <span className="text-xs text-blue-300 px-2 min-w-[3rem] text-center">
                {zoomLevel.toFixed(1)}x
              </span>
              <button
                onClick={zoomIn}
                className="p-1 text-blue-300 hover:text-blue-100 transition-colors"
                disabled={zoomLevel >= MAX_ZOOM}
              >
                <ZoomIn className="w-4 h-4" />
              </button>
              <button
                onClick={resetZoom}
                className="p-1 text-blue-300 hover:text-blue-100 transition-colors ml-1"
              >
                <Home className="w-4 h-4" />
              </button>
            </div>
          </div>
        </div>

        {/* Enhanced Waveform Canvas */}
        <div 
          ref={waveformContainerRef}
          className="relative mb-4"
        >
          <canvas
            ref={canvasRef}
            width={1200}
            height={CANVAS_HEIGHT}
            className={`w-full bg-black/30 rounded-lg border border-blue-400/10 transition-all duration-200 ${
              isDragging ? 'cursor-grabbing' : 
              hoveredAnnotation ? 'cursor-pointer' : 
              'cursor-crosshair hover:border-blue-400/30'
            }`}
            onWheel={handleWheel}
            onClick={handleCanvasClick}
            onMouseMove={handleMouseMove}
            onMouseLeave={handleMouseLeave}
            style={{ 
              cursor: isDragging ? 'grabbing' : 'grab',
              touchAction: 'none',
              minHeight: `${CANVAS_HEIGHT}px`
            }}
          />
          
          {/* Enhanced Annotation Tooltip */}
          {hoveredAnnotation && (
            <div
              className="absolute z-50 bg-black/95 backdrop-blur-sm text-blue-100 text-xs p-3 rounded-lg border border-blue-400/30 shadow-lg pointer-events-none max-w-xs"
              style={{
                left: Math.min(
                  Math.max(hoveredAnnotation.x - 100, 10), 
                  1200 - 200 - 10
                ),
                top: ANNOTATION_BUBBLE_HEIGHT + 15,
                animation: 'fadeIn 0.2s ease-out'
              }}
            >
              <div className="absolute -top-2 left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-b-4 border-transparent border-b-black/95"></div>
              
              <div className="font-medium text-blue-300 mb-1 flex items-center gap-2">
                <span>{hoveredAnnotation.user}</span>
                <span className="text-purple-400">â€¢</span>
                <span className="font-mono">{formatRulerTime(hoveredAnnotation.timestamp)}</span>
                <span 
                  className="w-2 h-2 rounded-full"
                  style={{ backgroundColor: getAnnotationColor(annotations.find(a => a.id === hoveredAnnotation.id)!) }}
                ></span>
              </div>
              <div className="text-blue-100 leading-relaxed mb-1">
                {hoveredAnnotation.text}
              </div>
              <div className="text-xs text-purple-400 capitalize flex items-center gap-1">
                <span>{hoveredAnnotation.type}</span>
                <span className="text-blue-300">â€¢ Click to jump</span>
              </div>
            </div>
          )}
          
          {/* Click Feedback Indicator */}
          {clickFeedback && (
            <div
              className="absolute pointer-events-none z-40"
              style={{
                left: clickFeedback.x - 20,
                top: CANVAS_HEIGHT / 2 - 20,
                width: 40,
                height: 40
              }}
            >
              <div className="w-full h-full rounded-full border-2 border-blue-200 animate-ping"></div>
              <div className="absolute inset-2 rounded-full bg-blue-200/20 animate-pulse"></div>
            </div>
          )}
          
          {/* Cursor Position Indicator */}
          {!isLoading && !error && (
            <div className="absolute bottom-2 right-2 text-xs text-blue-300/70 font-mono bg-black/50 px-2 py-1 rounded">
              {gridMode === 'musical' ? formatMusicalTime(currentTime) : formatRulerTime(currentTime)}
              <div className="text-xs text-purple-400/60 mt-1">
                G: Toggle grid â€¢ Shift+T: Tap tempo
              </div>
            </div>
          )}
        </div>

        {/* Time Ruler */}
        <div className="relative h-10 mb-4">
          <div className="absolute inset-0 bg-black/20 rounded border-t border-blue-400/10">
            {getTimeMarkers().map((marker, index) => (
              <div
                key={index}
                className="absolute top-0 bottom-0 flex flex-col"
                style={{ left: `${marker.position}%` }}
              >
                <div 
                  className={`w-px ${
                    marker.isMajor 
                      ? 'bg-blue-400 h-full' 
                      : 'bg-purple-400 h-1/2'
                  } ${
                    marker.isBar ? 'bg-blue-200 shadow-sm' : ''
                  }`}
                />
                
                {marker.isMajor && (
                  <div className="absolute top-full mt-1 transform -translate-x-1/2">
                    <span className={`text-xs font-mono whitespace-nowrap ${
                      marker.isBar 
                        ? 'text-blue-200 font-semibold' 
                        : 'text-blue-400'
                    }`}>
                      {gridMode === 'musical' ? marker.label : formatRulerTime(marker.time)}
                    </span>
                  </div>
                )}
              </div>
            ))}
            
            {/* Current time indicator */}
            {duration > 0 && (
              <div
                className="absolute top-0 bottom-0 w-px bg-blue-200 shadow-lg z-10"
                style={{
                  left: `${((currentTime - scrollOffset) / (duration / zoomLevel)) * 100}%`,
                  display: currentTime >= scrollOffset && currentTime <= scrollOffset + (duration / zoomLevel) ? 'block' : 'none'
                }}
              >
                <div className="absolute top-full mt-1 transform -translate-x-1/2">
                  <div className="bg-blue-600 text-white text-xs px-2 py-1 rounded font-mono whitespace-nowrap">
                    {gridMode === 'musical' ? formatMusicalTime(currentTime) : formatRulerTime(currentTime)}
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Controls */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <button
              onClick={skipBackward}
              className="p-2 text-blue-300 hover:text-blue-100 transition-colors"
            >
              <SkipBack className="w-5 h-5" />
            </button>
            
            <button
              onClick={togglePlayPause}
              className="w-12 h-12 bg-gradient-to-r from-blue-600 to-purple-600 rounded-full flex items-center justify-center hover:shadow-lg hover:shadow-blue-600/25 transition-all duration-300 hover:scale-105"
            >
              {isPlaying ? (
                <Pause className="w-6 h-6 text-white" />
              ) : (
                <Play className="w-6 h-6 text-white ml-1" />
              )}
            </button>
            
            <button
              onClick={skipForward}
              className="p-2 text-blue-300 hover:text-blue-100 transition-colors"
            >
              <SkipForward className="w-5 h-5" />
            </button>
          </div>

          <div className="text-sm text-blue-300 font-mono">
            {formatTime(currentTime)} / {formatTime(duration)}
          </div>

          <div className="flex items-center gap-2">
            <button
              onClick={toggleMute}
              className="p-2 text-blue-300 hover:text-blue-100 transition-colors"
            >
              {isMuted ? <VolumeX className="w-4 h-4" /> : <Volume2 className="w-4 h-4" />}
            </button>
            
            <input
              type="range"
              min="0"
              max="1"
              step="0.1"
              value={isMuted ? 0 : volume}
              onChange={(e) => handleVolumeChange(parseFloat(e.target.value))}
              className="w-20 h-1 bg-purple-600 rounded-lg appearance-none cursor-pointer"
            />
          </div>
        </div>
      </div>

      {/* Demo Annotation Info */}
      {showAnnotations && (
        <div className="bg-gradient-to-br from-purple-900/20 via-blue-900/20 to-indigo-900/20 backdrop-blur-md rounded-xl p-6 border border-blue-400/20">
          <h4 className="font-bold text-lg text-blue-100 mb-4">Demo Annotations</h4>
          <div className="space-y-3">
            {annotations.map((annotation) => (
              <div key={annotation.id} className="flex items-start gap-3 p-3 bg-black/20 rounded-lg">
                <div 
                  className="w-3 h-3 rounded-full mt-1 flex-shrink-0"
                  style={{ backgroundColor: getAnnotationColor(annotation) }}
                />
                <div className="flex-1">
                  <div className="flex items-center gap-2 mb-1">
                    <span className="text-blue-200 font-medium text-sm">{annotation.user.username}</span>
                    <span 
                      className="text-blue-400 text-xs font-mono cursor-pointer hover:text-blue-200"
                      onClick={() => seekTo(annotation.timestamp)}
                    >
                      {formatTime(annotation.timestamp)}
                    </span>
                    <span className="text-xs px-2 py-0.5 bg-blue-600/30 text-blue-200 rounded">
                      {annotation.annotationType}
                    </span>
                  </div>
                  <p className="text-blue-100 text-sm">{annotation.text}</p>
                </div>
              </div>
            ))}
          </div>
          <div className="mt-4 text-xs text-blue-400">
            ðŸ’¡ <strong>Demo Features:</strong> Click annotations to jump to timestamp â€¢ Use mouse wheel to zoom â€¢ 
            Press G to toggle grid mode â€¢ Press Shift+T for tap tempo
          </div>
        </div>
      )}
    </div>
  );
}